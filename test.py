import unittest
from wallet import *

class MainTest(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        print("\n----------------------------------------------------------------------------------------")
        print("!!! Starting Main Tests !!!")
        print("----------------------------------------------------------------------------------------\n")
        
        # cls.wallet = Main().import_private_key(
        #     100897809677138163174856952607694300238573305027534078569886890414323321447504)

        # # mn47osRQ4pTm9WSW3inczQnByBvG7wrhMj
        # cls.wallet2 = Main().import_private_key(
        #     53543775883506703906499148469479904297172220131041556152219913425601595776857)

        # cls.wallet3 = Main().import_private_key(
        #     11721815747117917583098828363610524599463178642721196404024595875870538950423)

        # mfke2PVhGePAy1GfZNotr6LeXfQ5nwnZTa
        cls.wallet4 = Main().import_private_key(
            100897809677138163174856952607694300238573305027534078569886890414323321447504)

        # # mhpzxr92VHqCXy3Zpat41vGgQuv9YcKzt7
        # cls.wallet5 = Main().import_private_key(
        #     12196958284001970079242031404833655250066517166607428365484251744560960260904)


    def test_private_key_generated(self):
        print("Wallet 5 address: {}".format(self.wallet5.get_address()))
        print("Should generate a private key on construction")
        wallet = Main()
        self.assertIsNotNone(wallet.get_private_key())

        print("Should generate a valid public key on the secp256k1 curve")
        self.assertTrue(wallet.is_public_key_valid())

        print("Should generate a valid address on the testnet")
        testnet_address = wallet.get_address(mainnet=False)
        print(testnet_address)
        self.assertTrue(testnet_address[0] != '1')

        print("Import a private key, temp method, will change this to a cleaner way of importing secrets using WIF")
        self.assertEqual('cV4KeBeyuaHct1fzoiXkjEjaNGGiVXwwhfRbUdJYqVLqArQk6UBb', self.wallet4.get_private_key())

        print("Should return this address as an address generated by private key")
        expected = "mfke2PVhGePAy1GfZNotr6LeXfQ5nwnZTa"
        self.assertEqual(expected, self.wallet4.get_address(mainnet=False))

        print("Should create a valid transaction and broadcast to the network")

        # First step is to create the transaction and send the hex
        # Next steps are to cache available UTXO's as TX objects

        ## This will is the address that is generated by the private key when Wallet() was initialized
        sending_address = "mwM7hxtkequUMuTJATjHisfp6VACgNgcfv"

        target_address = "mfke2PVhGePAy1GfZNotr6LeXfQ5nwnZTa"

        target_amount = 0.002
        change_amount = 0.014


        expected = "010000000199ab3f377992df2ccad0af99dc846af032fbd982f916d72715d2eb0f2828342d010000006b483045022100ac3e55420a7b9897f0da43ff7a076895d0ead13fda49926041124aca00c5d6070220245aaefc7047563e42baa350cc7424efcb03ef7e70e596c28b5eca7223fa663f01210275bdc1759e7ffb5fb1f07655d5572cec8219b28250acdbc7f936396884d196f2ffffffff0280841e00000000001976a914029692862d60b5f84ba706b37939d074b6c5808588acc0fb3900000000001976a914ada5b5ba34eb8774388d0ac30c5bc3c8e8afae0388ac00000000"

        print("Should raise run time error since the input used has been spent")
        with self.assertRaises(RuntimeError):
            response = self.wallet2.send_transaction(
                prev_tx=unhexlify('1b562bc7c059af8a61bec721bae5c8f47d929389049b38525045e6330ac7acf2'),
                prev_index=1,
                target_addr=target_address,
                amount=target_amount,
                change_amount=change_amount)

    def test_p2pkh_generation(self):
        print("Should generate this adderss: 'mwM7hxtkequUMuTJATjHisfp6VACgNgcfv'")
        expected = "mwM7hxtkequUMuTJATjHisfp6VACgNgcfv"

        self.assertEqual(expected, self.wallet2.get_address(mainnet=False))

        print("Should generate a p2pkh")
        expected = b'76a914029692862d60b5f84ba706b37939d074b6c5808588ac'

        self.assertEqual(expected, hexlify(generate_p2pkh_pub_key("mfke2PVhGePAy1GfZNotr6LeXfQ5nwnZTa")))

        print("Should generate a p2pkh for the change output")
        expected = b'76a914ada5b5ba34eb8774388d0ac30c5bc3c8e8afae0388ac'

        self.assertEqual(expected, hexlify(generate_p2pkh_pub_key(self.wallet2.get_address(mainnet=False))))

    
    def test_p2sh_generation(self):
        print("Should genrate a P2SH using wallet2 and wallet4")
 
        print("p2sh reedem script is generated")
        p2sh_reedemScript = generate_reedemScript(self.wallet2.sec, [unhexlify(self.wallet4.sec)])
        self.assertIsNotNone(p2sh_reedemScript)

        print("p2sh redeem script generated is valid")
        expected = b'52210275bdc1759e7ffb5fb1f07655d5572cec8219b28250acdbc7f936396884d196f221035fb3daf8558881ab26e0955e96eec75937c513d730c5ef5866b4a2a0bd52206052ae'
        self.assertEqual(expected, hexlify(p2sh_reedemScript))

        print("Should throw run time error, when passing empty list of pub keys")
        with self.assertRaises(RuntimeError):
            p2sh_reedemScript = generate_reedemScript(self.wallet2.sec, [])

        print("Should generate an address for reedeem script")
        print(hexlify(p2sh_reedemScript))

        p2sh_address = generate_p2sh_address(p2sh_reedemScript, mainnet=False)
        print("p2sh_address: {}".format(p2sh_address))
        self.assertIsNotNone(p2sh_address)

    def test_send_tx_to_p2sh(self):
        # Address: mhpzxr92VHqCXy3Zpat41vGgQuv9YcKzt7
        # SEC: b'02d0b55a1e551abfa7123d3e2130325b5cc77103108a84b91c05add554dfbebebf'

        # P2SH Address: 2N3gQkVbrV8Kam9Zv1G4QwuCt7oF2skpCPE
        # Redeem Script: 52210275bdc1759e7ffb5fb1f07655d5572cec8219b28250acdbc7f936396884d196f221035fb3daf8558881ab26e0955e96eec75937c513d730c5ef5866b4a2a0bd52206052ae

        print("Should hash160 correctly")
        redeem_script = b'52210275bdc1759e7ffb5fb1f07655d5572cec8219b28250acdbc7f936396884d196f221035fb3daf8558881ab26e0955e96eec75937c513d730c5ef5866b4a2a0bd52206052ae'
        redeem_script = unhexlify(redeem_script)
        h160 = hexlify(sha256_ripemd160(redeem_script)).decode('ascii')
        expected = b'7274a4081f8e7f7fd9b4d1f048e853e96c6352c5'.decode('ascii')

        self.assertEqual(expected, h160)


        # target_address = "2N3gQkVbrV8Kam9Zv1G4QwuCt7oF2skpCPE"
        print("Should generate correct address")
        target_address = generate_p2sh_address(redeem_script)
        expected = '2N3gQkVbrV8Kam9Zv1G4QwuCt7oF2skpCPE'
        print("Target address: {}".format(target_address))
        self.assertEqual(expected, target_address)
        
        # response = self.wallet5.send_transaction(
        #     prev_tx = unhexlify('7c95996721bba829589a622d4bed06410ab455a8be932271d53ec9630b586c20'), 
        #     prev_index = 0, 
        #     target_addr = 'mhpzxr92VHqCXy3Zpat41vGgQuv9YcKzt7', 
        #     amount = 0.019,
        #     change_amount = 0.001,
        #     redeem_script=unhexlify(b'52210275bdc1759e7ffb5fb1f07655d5572cec8219b28250acdbc7f936396884d196f221035fb3daf8558881ab26e0955e96eec75937c513d730c5ef5866b4a2a0bd52206052ae'),
        #     p2sh=False)
        
        # self.assertEqual(201, response)

        print("P2SH should contain the same hashed redeem script")
        p2sh_scriptPubKey = generate_p2sh_pub_key(target_address)
        print(p2sh_scriptPubKey)

        # Extracting p2sh from scriptPubKey
        stream = BytesIO(p2sh_scriptPubKey)
        current = stream.read(1)

        for i in range(2):
            current = stream.read(1)
            
        p2sh_addr_hash160 = b''
        while current != b'\x87':
            p2sh_addr_hash160 += current
            current = stream.read(1)

        p2sh_from_scriptPubKey = hexlify(p2sh_addr_hash160)
        reedeem_script_hash160 = hexlify(sha256_ripemd160(redeem_script))

        print("Hexed p2sh addr: {}".format(p2sh_from_scriptPubKey))
        print("Redeem Script hashed: {}".format(hexlify(sha256_ripemd160(redeem_script))))
        
        #Expecting: 7274a4081f8e7f7fd9b4d1f048e853e96c6352c5
        self.assertEqual(p2sh_from_scriptPubKey, reedeem_script_hash160)

        print("Should now take hash160 from script pub key and create address")
        expected = '2LSKzp4QheQU5VR1Zuaj91Q7jbnDFzPAZ1V'
        prefix = b'\xc0'
        print("P2SH from scriptPubKey: {}".format(p2sh_from_scriptPubKey))
        address = encode_base58_checksum(prefix + unhexlify(p2sh_from_scriptPubKey))

        self.assertEqual(expected, address)


        print("Should take address and decode base58 to get hash160")
        #7274a4081f8e7f7fd9b4d1f048e853e96c6352c5
        expected = b'7274a4081f8e7f7fd9b4d1f048e853e96c6352c5'
        hash160 = decode_base58(address)

        self.assertEqual(expected, hexlify(hash160))

        print("Address from Block Cypher is decoded to the same h160, what does this mean?")
        #7274a4081f8e7f7fd9b4d1f048e853e96c6352c5
        expected = b'7274a4081f8e7f7fd9b4d1f048e853e96c6352c5'
        h160 = decode_base58('2N3gQkVbrV8Kam9Zv1G4QwuCt7oF2skpCPE')
        
        self.assertEqual(expected, hexlify(h160))

    def test_get_balance(self):
        # Wallet 5
        print("Should return a the balance of wallet1 address")
        expected = satoshi_to_bitcoin(104900000)
        balance = satoshi_to_bitcoin(self.wallet5.get_balance())

        self.assertEqual(expected, balance)

    def test_get_UTXOs(self):
        # Wallet 4
        UTXOs = self.wallet4.UTXOs
        print("Should cache UTXOs in list in wallet object")
        self.assertIsNotNone(UTXOs)

        print("Should return a list of UTXOs greater than 0")
        print("Retrieved: {}".format(UTXOs))
        self.assertTrue(len(UTXOs) > 0)
        
        # print("Should get a prev tx of a UTXO")
        # expected = "7c95996721bba829589a622d4bed06410ab455a8be932271d53ec9630b586c20"
        # self.assertEqual(expected, UTXOs[0].tx_hash)

        print("Should only return a list of UTXO's of length 1")
        expected = 9
        self.assertEqual(expected, len(UTXOs))

       

    # def test_send_tx(self):
    #     # # Address of wallet1: mhpzxr92VHqCXy3Zpat41vGgQuv9YcKzt7
    #     # # Wallet 5

    #     # print("Address: {}".format(self.wallet5.get_address()))

    #     # # def send_transaction(self, prev_tx, prev_index, target_addr, amount, change_amount, redeem_script=None, p2sh=False):
    #     # response = self.wallet4.send_transaction(unhexlify('7c95996721bba829589a622d4bed06410ab455a8be932271d53ec9630b586c20'), 1, 'n1adMtYYKT72d3NKjbFiE7Wv4tHSpiEC9M', 1.039, 0.01)

    #     # self.assertEqual(409, response.status_code)

    #     # print("Should find the optimum inputs according to target output amount")
    #     # wallet2 = Main().import_private_key(11721815747117917583098828363610524599463178642721196404024595875870538950423)
    #     # print("Printing UTXOs: {}".format(wallet2.UTXOs))
    #     print("Printing Addres: {}".format(wallet2.get_address()))

    def test_UTXOs_on_start(self):
        # Address: n1adMtYYKT72d3NKjbFiE7Wv4tHSpiEC9M
        print("Should show a list of UTXOs when wallet is created")
        UTXOs = self.wallet3.UTXOs
        length_UTXOs = len(UTXOs)

        self.assertTrue(length_UTXOs > 0)

    def test_UTXOs_should_be_sorted(self):
        print("Should be sorted, UTXO object at 0 value should be less than UTXO Object - 1 value should be greater")
        length_of_UTXOs = len(self.wallet3.UTXOs)
        print(self.wallet3.UTXOs[0])

        print("Should have 0 index value less than the last index")
        self.assertTrue(self.wallet3.UTXOs[0].value < self.wallet3.UTXOs[length_of_UTXOs - 1].value)

        print("Should compare each object in list and counter + 1 should be greater")
        for counter, utxo_object in enumerate(self.wallet3.UTXOs):
            print("Value at Pos: {} : {}".format(utxo_object.value, counter))
            
            if counter + 1 < length_of_UTXOs:
                self.assertTrue(utxo_object.value <= self.wallet3.UTXOs[counter + 1].value)


    def test_calculate_inputs(self):
        # Find inputs that uses the lowest amount of inputs
        print("Should use only 1 input which is 0.65")
        
        # Send target_amount: 0.5
        # Need to return prev_tx and prev_index
        tx_inputs = self.wallet3.calculate_inputs(0.5)

        expected = ("9ea973ec92e0eed598d97810d74a0bf071f4b4ccee9ca97a91f57dda1ec0852a", 0)

        self.assertEqual(tx_inputs[0], expected)

        print("Should use only 2 inputs which is 0.65 and 5.29")
        
        # Send target_amount: 0.5
        # Need to return prev_tx and prev_index
        tx_inputs = self.wallet3.calculate_inputs(5.94)
        print("TX INputs: {}".format(tx_inputs))
        expected = [("9ea973ec92e0eed598d97810d74a0bf071f4b4ccee9ca97a91f57dda1ec0852a", 0), ("2ad07459a4f2645374efcb757cd423042683df3836bca0477c7c3dafd16cf624", 1)]

        self.assertEqual(tx_inputs, expected)

    def test_calculate_inputs_2(self):
        # address: mfke2PVhGePAy1GfZNotr6LeXfQ5nwnZTa
        # balance: 1.732

        # Values
        # UTXO's = [0.002, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.05, 0.2]

        # Prev Tx Hash
        prev_tx_UTXOs = [
                  "58c42ac1e288779141325a4750ccfcccdd8c6e9132119b16e9da002e052be7ea",
                  "1b562bc7c059af8a61bec721bae5c8f47d929389049b38525045e6330ac7acf2",
                  "6061273f139ad7dbb00d455a05c646f6019fd3ec932c537c75e6f210efdb378d",
                  "2d3428280febd21527d716f982d9fb32f06a84dc99afd0ca2cdf9279373fab99",
                  "aa2fccef0207026c455e69e92e81cdded46db14be68ef0b5271d46e0fee2d041",
                  "c1ecbdd8710816fccc2bd37ca582ea1fd4a80c8dec5b6707a3f68d8e89a6e69d",
                  "3d61300976656c17557e8b5794901b6deedb97b3a8a743a67ddd49e24ebb7428",
                  "95477007db114639655032b03036540982303d7e2c54f6e2944b066b60398fd9",
                  "fea5cbf4efc220a5512d394279778f75937c253cac32c43047cadffc9ee4d85c"
                 ]
        
        # Send target_amount: 0.0
        # Need to return prev_tx and prev_index
        tx_inputs = self.wallet4.calculate_inputs(0.02)
        print(tx_inputs)
        expected = 1

        print("Should use 1 input: 0.02")
        self.assertEqual(len(tx_inputs), expected)

        print("Should use prev tx hash at index 6 in prev_tx_UTXOs")
        self.assertEqual(prev_tx_UTXOs[6], tx_inputs[0][0])

        print("Should use 1 input, 0.05: 95477007db114639655032b03036540982303d7e2c54f6e2944b066b60398fd9")
        tx_inputs = self.wallet4.calculate_inputs(0.049)
        expected = 1

        self.assertEqual(len(tx_inputs), expected)
        self.assertEqual(prev_tx_UTXOs[7], tx_inputs[0][0])

        print("Should use 1 input, 0.002: 58c42ac1e288779141325a4750ccfcccdd8c6e9132119b16e9da002e052be7ea")
        tx_inputs = self.wallet4.calculate_inputs(0.00014853)
        expected = 1

        self.assertEqual(len(tx_inputs), expected)
        self.assertEqual(prev_tx_UTXOs[0], tx_inputs[0][0])


        

if __name__ == '__main__':
    unittest.main()